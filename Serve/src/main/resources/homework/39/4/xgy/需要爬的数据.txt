send函数不超过2300,当gas超过2300,相当于调用失败，
A有send函数，默认的功能是给普通账户发送以太币，但是会调到fallback函数，
为了防止循环调用，消耗过多gas, 就是可能忽视某些情况，然后存在风险，
调用send语句，爆出erroutofGas异常，然后0和2300都是为了判断是否调用send函数，
而不是call函数，潜在漏洞，应该处理，但是没处理
兴亚师兄：如果异常发生，一个特征是动态操作码是在send指令结束的

处理异常的方式不统一：
所以必须要在send外边加上判断是否异常
预言：
如果原始的call没有抛异常,里面抛异常，则认为存在风险

重入：
1、是否调用A超过一次
2、用来检查call发送是否大于0,是否有足够的gas可以执行，代理合约调待测合约
通过间接相似性来判断是否存在漏洞

时间依赖：
Timestampop 操作去检查是否存在时间依赖，检查调用是否是通过send这个方式来发送的，检测是否在交易中打了钱

块号依赖
使用number和是否打钱

委托调用
使用代理调用，指定自己合约中的函数在被调用函数的上下文中执行，比如自杀函数
预言：
1、调用delegatecall操作码
2、地址可以操控，不是写死的
然后操作码的权重要被放大

冻结以太币
一个合约里没有任何一个发送以太币的函数，完全依赖于第三方合约，但是如果第三方合约自杀，则第三方合约的以太币会被冻结
contractfuzzer没有实现


函数依赖于参数，而这个参数是另一个合约的地址，但我到了测试链上，参数应该填什么？

contractfuzzer里面地址是写死的

需要合约构造函数的参数

考虑三种账户：合约部署者，普通账户、攻击合约

两种模式：发币，不发币

地址准备、








